{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/@turf/bbox-polygon/index.js","node_modules/@turf/bbox/index.js","node_modules/@turf/bearing/index.js","node_modules/@turf/boolean-contains/index.js","node_modules/@turf/boolean-overlap/index.js","node_modules/@turf/boolean-point-in-polygon/index.js","node_modules/@turf/boolean-point-on-line/index.js","node_modules/@turf/center/index.js","node_modules/@turf/clean-coords/main.js","node_modules/@turf/clean-coords/node_modules/@turf/helpers/main.js","node_modules/@turf/clean-coords/node_modules/@turf/invariant/main.js","node_modules/@turf/clone/main.js","node_modules/@turf/destination/index.js","node_modules/@turf/distance/index.js","node_modules/@turf/helpers/index.js","node_modules/@turf/invariant/index.js","node_modules/@turf/line-intersect/index.js","node_modules/@turf/line-overlap/index.js","node_modules/@turf/line-segment/index.js","node_modules/@turf/meta/index.js","node_modules/@turf/nearest-point-on-line/index.js","node_modules/@turf/simplify/main.js","node_modules/@turf/simplify/node_modules/@turf/meta/main.js","node_modules/deep-equal/index.js","node_modules/define-properties/index.js","node_modules/function-bind/implementation.js","node_modules/function-bind/index.js","node_modules/geojson-equality/index.js","node_modules/geojson-rbush/index.js","node_modules/has/src/index.js","node_modules/is-arguments/index.js","node_modules/is-date-object/index.js","node_modules/is-regex/index.js","node_modules/object-is/index.js","node_modules/object-keys/implementation.js","node_modules/object-keys/index.js","node_modules/object-keys/isArguments.js","node_modules/quickselect/quickselect.js","node_modules/rbush/index.js","node_modules/regexp.prototype.flags/implementation.js","node_modules/regexp.prototype.flags/index.js","node_modules/regexp.prototype.flags/polyfill.js","node_modules/regexp.prototype.flags/shim.js","src/build/turf-build.js"],"names":["bboxPolygon","bbox","options","west","Number","south","east","north","length","Error","lowLeft","topLeft","topRight","lowRight","helpers_1","polygon","properties","id","Object","defineProperty","exports","value","require","default","geojson","result","Infinity","meta_1","coordEach","coord","bearing","start","end","final","calculateFinalBearing","coordinates1","invariant_1","getCoord","coordinates2","lon1","degreesToRadians","lon2","lat1","lat2","a","Math","sin","cos","b","radiansToDegrees","atan2","bear","booleanContains","feature1","feature2","geom1","getGeom","geom2","type1","getType","type2","coords1","getCoords","coords2","compareCoords","isPointInMultiPoint","isMultiPointInMultiPoint","boolean_point_on_line_1","ignoreEndVertices","isLineOnLine","isMultiPointOnLine","boolean_point_in_polygon_1","ignoreBoundary","isLineInPoly","isPolyInPoly","isMultiPointInPoly","multiPoint","pt","i","output","coordinates","multiPoint1","multiPoint2","_i","_a","coord2","matchFound","_b","_c","lineString","haveFoundInteriorPoint","lineString1","lineString2","coords","type","linestring","doBBoxOverlap","bbox_1","midPoint","getMidpoint","geometry","coords_1","ring","ring_1","bbox1","bbox2","pair1","pair2","__importDefault","this","mod","__esModule","booleanOverlap","GeojsonEquality","precision","compare","overlap","coordAll","forEach","coord1","segmentEach","segment1","segment2","line_overlap_1","features","line_intersect_1","booleanPointInPolygon","point","geom","polys","inBBox","insidePoly","inRing","inHole","k","isInside","slice","j","xi","yi","xj","yj","booleanPointOnLine","line","ptCoords","lineCoords","isPointOnLineSegment","lineSegmentStart","lineSegmentEnd","excludeBoundary","x","y","x1","y1","x2","y2","dxc","dyc","dxl","dyl","abs","center","ext","cleanCoords","mutate","invariant","newCoords","cleanLine","push","polygons","polyPoints","existing","key","join","hasOwnProperty","helpers","feature","points","equals","prevPoint","nextPoint","newPoints","secondToLast","pt1","pt2","startX","startY","endX","endY","module","isObject","undefined","constructor","validateBBox","validateId","feat","Array","isArray","multiLineString","multiPolygon","isNumber","featureCollection","map","lineStrings","fc","geometryCollection","geometries","round","num","isNaN","multiplier","pow","radiansToLength","radians","units","factor","factors","lengthToRadians","distance","lengthToDegrees","bearingToAzimuth","angle","PI","degrees","convertLength","originalUnit","finalUnit","convertArea","area","startFactor","areaFactors","finalFactor","input","indexOf","radians2degrees","degrees2radians","distanceToDegrees","distanceToRadians","radiansToDistance","bearingToAngle","convertDistance","earthRadius","meters","metres","millimeters","millimetres","centimeters","centimetres","kilometers","kilometres","miles","nauticalmiles","inches","yards","feet","unitsFactors","acres","containsNumber","geojsonType","name","featureOf","collectionOf","getGeomType","clone","cloneFeature","cloneFeatureCollection","cloneGeometry","cloned","keys","cloneProperties","item","deepSlice","destination","origin","longitude1","latitude1","bearingRad","latitude2","asin","longitude2","lng","lat","from","to","dLat","dLon","sqrt","coordinates_1","test","lineIntersect","line1","line2","unique","results","intersect","intersects","tree","geojson_rbush_1","load","line_segment_1","featureEach","segment","search","match","x3","y3","x4","y4","denom","numeA","numeB","uA","uB","lineOverlap","tolerance","overlapSegment","doesOverlaps","coordsSegment","sort","coordsMatch","equal","concatSegment","nearest_point_on_line_1","dist","unshift","lineSegment","flattenEach","lineSegmentFeature","createSegments","segments","reduce","previousCoords","currentCoords","callback","excludeWrapCoord","l","stopG","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","coordReduce","initialValue","previousValue","currentCoord","propEach","propReduce","currentProperties","featureReduce","currentFeature","geomEach","g","featureProperties","featureBBox","featureId","geomReduce","currentGeometry","coordinate","flattenReduce","segmentIndex","previousFeatureIndex","previousMultiIndex","prevGeomIndex","featureIndexCoord","multiPartIndexCoord","currentSegment","segmentReduce","started","lineEach","lineReduce","currentLine","findSegment","findPoint","nearestPointOnLine","lines","closestPt","distance_1","stop_1","sectionLength","heightDistance","max","direction","bearing_1","perpendicularPt1","destination_1","perpendicularPt2","intersectPt","location","index","_interopDefault","ex","getSqDist","p1","p2","dx","dy","getSqSegDist","p","t","simplifyRadialDist","sqTolerance","len","simplifyDPStep","first","last","simplified","maxSqDist","sqDist","simplifyDouglasPeucker","simplify$2","highestQuality","simplify","highQuality","meta","simplifyGeom","simplifyLine","simplifyPolygon","rings","z","pts","simpleRing","checkValidity","feature$$1","mutliPartIndexCoord","deepEqual","actual","expected","opts","strict","is","objEquiv","isUndefinedOrNull","isBuffer","copy","prototype","isArguments","aIsRegex","isRegex","bIsRegex","source","flags","isDate","getTime","call","aIsBuffer","bIsBuffer","ka","objectKeys","kb","e","Date","hasSymbols","Symbol","toStr","toString","concat","origDefineProperty","isFunction","fn","arePropertyDescriptorsSupported","obj","enumerable","_","supportsDescriptors","object","predicate","configurable","writable","defineProperties","predicates","arguments","props","getOwnPropertySymbols","ERROR_MESSAGE","funcType","that","target","TypeError","bound","args","binder","apply","boundLength","boundArgs","Function","Empty","implementation","bind","explode","part","replace","sameLength","g1","g2","objectComparator","obj1","obj2","Equality","opt","pseudoNode","compareCoord","compareLine","comparePolygon","compareFeature","context","g1s","g2s","every","g1part","some","g2part","c1","c2","toFixed","path1","path2","ind","isPoly","removePseudo","fixStartIndex","sameDirection","comparePath","reverse","sourcePath","targetPath","correctPath","cont","c","holes1","holes2","h1","h2","compareBBox","path","geojsonRbush","maxEntries","rbush","insert","turfBBox","remove","clear","toBBox","collides","all","toJSON","fromJSON","json","minX","minY","maxX","maxY","hasToStringTag","toStringTag","isStandardArguments","isLegacyArguments","callee","supportsStandardArguments","getDay","tryDateObject","dateClass","has","regexExec","RegExp","exec","gOPD","getOwnPropertyDescriptor","tryRegexExecCall","lastIndex","regexClass","descriptor","NumberIsNaN","keysShim","isArgs","isEnumerable","propertyIsEnumerable","hasDontEnumBug","hasProtoEnumBug","dontEnums","equalsConstructorPrototype","o","ctor","excludedKeys","$applicationCache","$console","$external","$frame","$frameElement","$frames","$innerHeight","$innerWidth","$onmozfullscreenchange","$onmozfullscreenerror","$outerHeight","$outerWidth","$pageXOffset","$pageYOffset","$parent","$scrollLeft","$scrollTop","$scrollX","$scrollY","$self","$webkitIndexedDB","$webkitStorageInfo","$window","hasAutomationEqualityBug","window","equalsConstructorPrototypeIfNotBuggy","isString","theKeys","skipProto","String","skipConstructor","origKeys","originalKeys","shim","str","global","factory","define","amd","quickselect","arr","left","right","quickselectStep","defaultCompare","n","m","log","s","exp","sd","floor","min","swap","tmp","format","_maxEntries","_minEntries","ceil","_initFormat","findItem","items","equalsFn","calcBBox","node","distBBox","children","destNode","createNode","child","extend","leaf","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","enlargedArea","intersectionArea","contains","height","multiSelect","mid","stack","pop","_all","data","childBBox","nodesToSearch","_build","_splitRoot","tmpNode","_insert","parent","goingUp","indexes","splice","_condense","compareMinX","compareMinY","N","M","right2","right3","N2","N1","_chooseSubtree","level","targetNode","enlargement","minArea","minEnlargement","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","minOverlap","_allDistMargin","leftBBox","rightBBox","margin","siblings","compareArr","toObject","TypeErr","ignoreCase","multiline","dotAll","unicode","sticky","getPolyfill","flagsBound","get","getProto","getPrototypeOf","regex","polyfill","proto"],"mappings":"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","file":"bundle.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = require(\"@turf/helpers\");\n/**\n * Takes a bbox and returns an equivalent {@link Polygon|polygon}.\n *\n * @name bboxPolygon\n * @param {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @param {Object} [options={}] Optional parameters\n * @param {Properties} [options.properties={}] Translate properties to Polygon\n * @param {string|number} [options.id={}] Translate Id to Polygon\n * @returns {Feature<Polygon>} a Polygon representation of the bounding box\n * @example\n * var bbox = [0, 0, 10, 10];\n *\n * var poly = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [poly]\n */\nfunction bboxPolygon(bbox, options) {\n    if (options === void 0) { options = {}; }\n    // Convert BBox positions to Numbers\n    // No performance loss for including Number()\n    // https://github.com/Turfjs/turf/issues/1119\n    var west = Number(bbox[0]);\n    var south = Number(bbox[1]);\n    var east = Number(bbox[2]);\n    var north = Number(bbox[3]);\n    if (bbox.length === 6) {\n        throw new Error(\"@turf/bbox-polygon does not support BBox with 6 positions\");\n    }\n    var lowLeft = [west, south];\n    var topLeft = [west, north];\n    var topRight = [east, north];\n    var lowRight = [east, south];\n    return helpers_1.polygon([[\n            lowLeft,\n            lowRight,\n            topRight,\n            topLeft,\n            lowLeft,\n        ]], options.properties, { bbox: bbox, id: options.id });\n}\nexports.default = bboxPolygon;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    meta_1.coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nexports.default = bbox;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\n// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nfunction bearing(start, end, options) {\n    if (options === void 0) { options = {}; }\n    // Reverse calculation\n    if (options.final === true) {\n        return calculateFinalBearing(start, end);\n    }\n    var coordinates1 = invariant_1.getCoord(start);\n    var coordinates2 = invariant_1.getCoord(end);\n    var lon1 = helpers_1.degreesToRadians(coordinates1[0]);\n    var lon2 = helpers_1.degreesToRadians(coordinates2[0]);\n    var lat1 = helpers_1.degreesToRadians(coordinates1[1]);\n    var lat2 = helpers_1.degreesToRadians(coordinates2[1]);\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n    return helpers_1.radiansToDegrees(Math.atan2(a, b));\n}\n/**\n * Calculates Final Bearing\n *\n * @private\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\nexports.default = bearing;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bbox_1 = __importDefault(require(\"@turf/bbox\"));\nvar boolean_point_in_polygon_1 = __importDefault(require(\"@turf/boolean-point-in-polygon\"));\nvar boolean_point_on_line_1 = __importDefault(require(\"@turf/boolean-point-on-line\"));\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Boolean-contains returns True if the second geometry is completely contained by the first geometry.\n * The interiors of both geometries must intersect and, the interior and boundary of the secondary (geometry b)\n * must not intersect the exterior of the primary (geometry a).\n * Boolean-contains returns the exact opposite result of the `@turf/boolean-within`.\n *\n * @name booleanContains\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n * var point = turf.point([1, 2]);\n *\n * turf.booleanContains(line, point);\n * //=true\n */\nfunction booleanContains(feature1, feature2) {\n    var geom1 = invariant_1.getGeom(feature1);\n    var geom2 = invariant_1.getGeom(feature2);\n    var type1 = invariant_1.getType(feature1);\n    var type2 = invariant_1.getType(feature2);\n    var coords1 = invariant_1.getCoords(feature1);\n    var coords2 = invariant_1.getCoords(feature2);\n    switch (type1) {\n        case \"Point\":\n            switch (type2) {\n                case \"Point\":\n                    return compareCoords(coords1, coords2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"MultiPoint\":\n            switch (type2) {\n                case \"Point\":\n                    return isPointInMultiPoint(geom1, geom2);\n                case \"MultiPoint\":\n                    return isMultiPointInMultiPoint(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"LineString\":\n            switch (type2) {\n                case \"Point\":\n                    return boolean_point_on_line_1.default(geom2, geom1, { ignoreEndVertices: true });\n                case \"LineString\":\n                    return isLineOnLine(geom1, geom2);\n                case \"MultiPoint\":\n                    return isMultiPointOnLine(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"Polygon\":\n            switch (type2) {\n                case \"Point\":\n                    return boolean_point_in_polygon_1.default(geom2, geom1, { ignoreBoundary: true });\n                case \"LineString\":\n                    return isLineInPoly(geom1, geom2);\n                case \"Polygon\":\n                    return isPolyInPoly(geom1, geom2);\n                case \"MultiPoint\":\n                    return isMultiPointInPoly(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        default:\n            throw new Error(\"feature1 \" + type1 + \" geometry not supported\");\n    }\n}\nexports.default = booleanContains;\nfunction isPointInMultiPoint(multiPoint, pt) {\n    var i;\n    var output = false;\n    for (i = 0; i < multiPoint.coordinates.length; i++) {\n        if (compareCoords(multiPoint.coordinates[i], pt.coordinates)) {\n            output = true;\n            break;\n        }\n    }\n    return output;\n}\nexports.isPointInMultiPoint = isPointInMultiPoint;\nfunction isMultiPointInMultiPoint(multiPoint1, multiPoint2) {\n    for (var _i = 0, _a = multiPoint2.coordinates; _i < _a.length; _i++) {\n        var coord2 = _a[_i];\n        var matchFound = false;\n        for (var _b = 0, _c = multiPoint1.coordinates; _b < _c.length; _b++) {\n            var coord1 = _c[_b];\n            if (compareCoords(coord2, coord1)) {\n                matchFound = true;\n                break;\n            }\n        }\n        if (!matchFound) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isMultiPointInMultiPoint = isMultiPointInMultiPoint;\nfunction isMultiPointOnLine(lineString, multiPoint) {\n    var haveFoundInteriorPoint = false;\n    for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (boolean_point_on_line_1.default(coord, lineString, { ignoreEndVertices: true })) {\n            haveFoundInteriorPoint = true;\n        }\n        if (!boolean_point_on_line_1.default(coord, lineString)) {\n            return false;\n        }\n    }\n    if (haveFoundInteriorPoint) {\n        return true;\n    }\n    return false;\n}\nexports.isMultiPointOnLine = isMultiPointOnLine;\nfunction isMultiPointInPoly(polygon, multiPoint) {\n    for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (!boolean_point_in_polygon_1.default(coord, polygon, { ignoreBoundary: true })) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isMultiPointInPoly = isMultiPointInPoly;\nfunction isLineOnLine(lineString1, lineString2) {\n    var haveFoundInteriorPoint = false;\n    for (var _i = 0, _a = lineString2.coordinates; _i < _a.length; _i++) {\n        var coords = _a[_i];\n        if (boolean_point_on_line_1.default({ type: \"Point\", coordinates: coords }, lineString1, { ignoreEndVertices: true })) {\n            haveFoundInteriorPoint = true;\n        }\n        if (!boolean_point_on_line_1.default({ type: \"Point\", coordinates: coords }, lineString1, { ignoreEndVertices: false })) {\n            return false;\n        }\n    }\n    return haveFoundInteriorPoint;\n}\nexports.isLineOnLine = isLineOnLine;\nfunction isLineInPoly(polygon, linestring) {\n    var output = false;\n    var i = 0;\n    var polyBbox = bbox_1.default(polygon);\n    var lineBbox = bbox_1.default(linestring);\n    if (!doBBoxOverlap(polyBbox, lineBbox)) {\n        return false;\n    }\n    for (i; i < linestring.coordinates.length - 1; i++) {\n        var midPoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);\n        if (boolean_point_in_polygon_1.default({ type: \"Point\", coordinates: midPoint }, polygon, { ignoreBoundary: true })) {\n            output = true;\n            break;\n        }\n    }\n    return output;\n}\nexports.isLineInPoly = isLineInPoly;\n/**\n * Is Polygon2 in Polygon1\n * Only takes into account outer rings\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @returns {boolean} true/false\n */\nfunction isPolyInPoly(feature1, feature2) {\n    // Handle Nulls\n    if (feature1.type === \"Feature\" && feature1.geometry === null) {\n        return false;\n    }\n    if (feature2.type === \"Feature\" && feature2.geometry === null) {\n        return false;\n    }\n    var poly1Bbox = bbox_1.default(feature1);\n    var poly2Bbox = bbox_1.default(feature2);\n    if (!doBBoxOverlap(poly1Bbox, poly2Bbox)) {\n        return false;\n    }\n    var coords = invariant_1.getGeom(feature2).coordinates;\n    for (var _i = 0, coords_1 = coords; _i < coords_1.length; _i++) {\n        var ring = coords_1[_i];\n        for (var _a = 0, ring_1 = ring; _a < ring_1.length; _a++) {\n            var coord = ring_1[_a];\n            if (!boolean_point_in_polygon_1.default(coord, feature1)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nexports.isPolyInPoly = isPolyInPoly;\nfunction doBBoxOverlap(bbox1, bbox2) {\n    if (bbox1[0] > bbox2[0]) {\n        return false;\n    }\n    if (bbox1[2] < bbox2[2]) {\n        return false;\n    }\n    if (bbox1[1] > bbox2[1]) {\n        return false;\n    }\n    if (bbox1[3] < bbox2[3]) {\n        return false;\n    }\n    return true;\n}\nexports.doBBoxOverlap = doBBoxOverlap;\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nfunction compareCoords(pair1, pair2) {\n    return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nexports.compareCoords = compareCoords;\nfunction getMidpoint(pair1, pair2) {\n    return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];\n}\nexports.getMidpoint = getMidpoint;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = require(\"@turf/meta\");\nvar invariant_1 = require(\"@turf/invariant\");\nvar line_overlap_1 = require(\"@turf/line-overlap\");\nvar line_intersect_1 = require(\"@turf/line-intersect\");\nvar GeojsonEquality = require(\"geojson-equality\");\n/**\n * Compares two geometries of the same dimension and returns true if their intersection set results in a geometry\n * different from both but of the same dimension. It applies to Polygon/Polygon, LineString/LineString,\n * Multipoint/Multipoint, MultiLineString/MultiLineString and MultiPolygon/MultiPolygon.\n *\n * @name booleanOverlap\n * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature1 input\n * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature2 input\n * @returns {boolean} true/false\n * @example\n * var poly1 = turf.polygon([[[0,0],[0,5],[5,5],[5,0],[0,0]]]);\n * var poly2 = turf.polygon([[[1,1],[1,6],[6,6],[6,1],[1,1]]]);\n * var poly3 = turf.polygon([[[10,10],[10,15],[15,15],[15,10],[10,10]]]);\n *\n * turf.booleanOverlap(poly1, poly2)\n * //=true\n * turf.booleanOverlap(poly2, poly3)\n * //=false\n */\nfunction booleanOverlap(feature1, feature2) {\n    // validation\n    if (!feature1)\n        throw new Error('feature1 is required');\n    if (!feature2)\n        throw new Error('feature2 is required');\n    var type1 = invariant_1.getType(feature1);\n    var type2 = invariant_1.getType(feature2);\n    if (type1 !== type2)\n        throw new Error('features must be of the same type');\n    if (type1 === 'Point')\n        throw new Error('Point geometry not supported');\n    // features must be not equal\n    var equality = new GeojsonEquality({ precision: 6 });\n    if (equality.compare(feature1, feature2))\n        return false;\n    var overlap = 0;\n    switch (type1) {\n        case 'MultiPoint':\n            var coords1 = meta_1.coordAll(feature1);\n            var coords2 = meta_1.coordAll(feature2);\n            coords1.forEach(function (coord1) {\n                coords2.forEach(function (coord2) {\n                    if (coord1[0] === coord2[0] && coord1[1] === coord2[1])\n                        overlap++;\n                });\n            });\n            break;\n        case 'LineString':\n        case 'MultiLineString':\n            meta_1.segmentEach(feature1, function (segment1) {\n                meta_1.segmentEach(feature2, function (segment2) {\n                    if (line_overlap_1.default(segment1, segment2).features.length)\n                        overlap++;\n                });\n            });\n            break;\n        case 'Polygon':\n        case 'MultiPolygon':\n            meta_1.segmentEach(feature1, function (segment1) {\n                meta_1.segmentEach(feature2, function (segment2) {\n                    if (line_intersect_1.default(segment1, segment2).features.length)\n                        overlap++;\n                });\n            });\n            break;\n    }\n    return overlap > 0;\n}\nexports.default = booleanOverlap;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant_1 = require(\"@turf/invariant\");\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nfunction booleanPointInPolygon(point, polygon, options) {\n    if (options === void 0) { options = {}; }\n    // validation\n    if (!point) {\n        throw new Error(\"point is required\");\n    }\n    if (!polygon) {\n        throw new Error(\"polygon is required\");\n    }\n    var pt = invariant_1.getCoord(point);\n    var geom = invariant_1.getGeom(polygon);\n    var type = geom.type;\n    var bbox = polygon.bbox;\n    var polys = geom.coordinates;\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) {\n        return false;\n    }\n    // normalize to multipolygon\n    if (type === \"Polygon\") {\n        polys = [polys];\n    }\n    var insidePoly = false;\n    for (var i = 0; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) {\n                insidePoly = true;\n            }\n        }\n    }\n    return insidePoly;\n}\nexports.default = booleanPointInPolygon;\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1);\n    }\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0];\n        var yi = ring[i][1];\n        var xj = ring[j][0];\n        var yj = ring[j][1];\n        var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&\n            ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);\n        if (onBoundary) {\n            return !ignoreBoundary;\n        }\n        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&\n            (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return bbox[0] <= pt[0] &&\n        bbox[1] <= pt[1] &&\n        bbox[2] >= pt[0] &&\n        bbox[3] >= pt[1];\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Returns true if a point is on a line. Accepts a optional parameter to ignore the\n * start and end vertices of the linestring.\n *\n * @name booleanPointOnLine\n * @param {Coord} pt GeoJSON Point\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.\n * @returns {boolean} true/false\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);\n * var isPointOnLine = turf.booleanPointOnLine(pt, line);\n * //=true\n */\nfunction booleanPointOnLine(pt, line, options) {\n    if (options === void 0) { options = {}; }\n    // Normalize inputs\n    var ptCoords = invariant_1.getCoord(pt);\n    var lineCoords = invariant_1.getCoords(line);\n    // Main\n    for (var i = 0; i < lineCoords.length - 1; i++) {\n        var ignoreBoundary = false;\n        if (options.ignoreEndVertices) {\n            if (i === 0) {\n                ignoreBoundary = \"start\";\n            }\n            if (i === lineCoords.length - 2) {\n                ignoreBoundary = \"end\";\n            }\n            if (i === 0 && i + 1 === lineCoords.length - 1) {\n                ignoreBoundary = \"both\";\n            }\n        }\n        if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary)) {\n            return true;\n        }\n    }\n    return false;\n}\n// See http://stackoverflow.com/a/4833823/1979085\n/**\n * @private\n * @param {Position} lineSegmentStart coord pair of start of line\n * @param {Position} lineSegmentEnd coord pair of end of line\n * @param {Position} pt coord pair of point to check\n * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends.\n * If true which end to ignore.\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary) {\n    var x = pt[0];\n    var y = pt[1];\n    var x1 = lineSegmentStart[0];\n    var y1 = lineSegmentStart[1];\n    var x2 = lineSegmentEnd[0];\n    var y2 = lineSegmentEnd[1];\n    var dxc = pt[0] - x1;\n    var dyc = pt[1] - y1;\n    var dxl = x2 - x1;\n    var dyl = y2 - y1;\n    var cross = dxc * dyl - dyc * dxl;\n    if (cross !== 0) {\n        return false;\n    }\n    if (!excludeBoundary) {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;\n    }\n    else if (excludeBoundary === \"start\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;\n    }\n    else if (excludeBoundary === \"end\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;\n    }\n    else if (excludeBoundary === \"both\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;\n    }\n    return false;\n}\nexports.default = booleanPointOnLine;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bbox_1 = require(\"@turf/bbox\");\nvar helpers_1 = require(\"@turf/helpers\");\n/**\n * Takes a {@link Feature} or {@link FeatureCollection} and returns the absolute center point of all features.\n *\n * @name center\n * @param {GeoJSON} geojson GeoJSON to be centered\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] Translate GeoJSON Properties to Point\n * @param {Object} [options.bbox={}] Translate GeoJSON BBox to Point\n * @param {Object} [options.id={}] Translate GeoJSON Id to Point\n * @returns {Feature<Point>} a Point feature at the absolute center point of all input features\n * @example\n * var features = turf.points([\n *   [-97.522259, 35.4691],\n *   [-97.502754, 35.463455],\n *   [-97.508269, 35.463245]\n * ]);\n *\n * var center = turf.center(features);\n *\n * //addToMap\n * var addToMap = [features, center]\n * center.properties['marker-size'] = 'large';\n * center.properties['marker-color'] = '#000';\n */\nfunction center(geojson, options) {\n    if (options === void 0) { options = {}; }\n    var ext = bbox_1.default(geojson);\n    var x = (ext[0] + ext[2]) / 2;\n    var y = (ext[1] + ext[3]) / 2;\n    return helpers_1.point([x, y], options.properties, options);\n}\nexports.default = center;\n","'use strict';\n\nvar helpers = require('@turf/helpers');\nvar invariant = require('@turf/invariant');\n\n/**\n * Removes redundant coordinates from any GeoJSON Geometry.\n *\n * @name cleanCoords\n * @param {Geometry|Feature} geojson Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated\n * @returns {Geometry|Feature} the cleaned input Feature/Geometry\n * @example\n * var line = turf.lineString([[0, 0], [0, 2], [0, 5], [0, 8], [0, 8], [0, 10]]);\n * var multiPoint = turf.multiPoint([[0, 0], [0, 0], [2, 2]]);\n *\n * turf.cleanCoords(line).geometry.coordinates;\n * //= [[0, 0], [0, 10]]\n *\n * turf.cleanCoords(multiPoint).geometry.coordinates;\n * //= [[0, 0], [2, 2]]\n */\nfunction cleanCoords(geojson, options) {\n    // Backwards compatible with v4.0\n    var mutate = (typeof options === 'object') ? options.mutate : options;\n    if (!geojson) throw new Error('geojson is required');\n    var type = invariant.getType(geojson);\n\n    // Store new \"clean\" points in this Array\n    var newCoords = [];\n\n    switch (type) {\n    case 'LineString':\n        newCoords = cleanLine(geojson);\n        break;\n    case 'MultiLineString':\n    case 'Polygon':\n        invariant.getCoords(geojson).forEach(function (line) {\n            newCoords.push(cleanLine(line));\n        });\n        break;\n    case 'MultiPolygon':\n        invariant.getCoords(geojson).forEach(function (polygons) {\n            var polyPoints = [];\n            polygons.forEach(function (ring) {\n                polyPoints.push(cleanLine(ring));\n            });\n            newCoords.push(polyPoints);\n        });\n        break;\n    case 'Point':\n        return geojson;\n    case 'MultiPoint':\n        var existing = {};\n        invariant.getCoords(geojson).forEach(function (coord) {\n            var key = coord.join('-');\n            if (!existing.hasOwnProperty(key)) {\n                newCoords.push(coord);\n                existing[key] = true;\n            }\n        });\n        break;\n    default:\n        throw new Error(type + ' geometry not supported');\n    }\n\n    // Support input mutation\n    if (geojson.coordinates) {\n        if (mutate === true) {\n            geojson.coordinates = newCoords;\n            return geojson;\n        }\n        return {type: type, coordinates: newCoords};\n    } else {\n        if (mutate === true) {\n            geojson.geometry.coordinates = newCoords;\n            return geojson;\n        }\n        return helpers.feature({type: type, coordinates: newCoords}, geojson.properties, geojson.bbox, geojson.id);\n    }\n}\n\n/**\n * Clean Coords\n *\n * @private\n * @param {Array<number>|LineString} line Line\n * @returns {Array<number>} Cleaned coordinates\n */\nfunction cleanLine(line) {\n    var points = invariant.getCoords(line);\n    // handle \"clean\" segment\n    if (points.length === 2 && !equals(points[0], points[1])) return points;\n\n    var prevPoint, point, nextPoint;\n    var newPoints = [];\n    var secondToLast = points.length - 1;\n\n    newPoints.push(points[0]);\n    for (var i = 1; i < secondToLast; i++) {\n        prevPoint = points[i - 1];\n        point = points[i];\n        nextPoint = points[i + 1];\n\n        if (!isPointOnLineSegment(prevPoint, nextPoint, point)) {\n            newPoints.push(point);\n        }\n    }\n    newPoints.push(nextPoint);\n    return newPoints;\n}\n\n/**\n * Compares two points and returns if they are equals\n *\n * @private\n * @param {Position} pt1 point\n * @param {Position} pt2 point\n * @returns {boolean} true if they are equals\n */\nfunction equals(pt1, pt2) {\n    return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n}\n\n/**\n * Returns if `point` is on the segment between `start` and `end`.\n * Borrowed from `@turf/boolean-point-on-line` to speed up the evaluation (instead of using the module as dependency)\n *\n * @private\n * @param {Position} start coord pair of start of line\n * @param {Position} end coord pair of end of line\n * @param {Position} point coord pair of point to check\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(start, end, point) {\n    var x = point[0], y = point[1];\n    var startX = start[0], startY = start[1];\n    var endX = end[0], endY = end[1];\n\n    var dxc = x - startX;\n    var dyc = y - startY;\n    var dxl = endX - startX;\n    var dyl = endY - startY;\n    var cross = dxc * dyl - dyc * dxl;\n\n    if (cross !== 0) return false;\n    else if (Math.abs(dxl) >= Math.abs(dyl)) return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;\n    else return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;\n}\n\nmodule.exports = cleanCoords;\nmodule.exports.default = cleanCoords;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexports.earthRadius = earthRadius;\nexports.factors = factors;\nexports.unitsFactors = unitsFactors;\nexports.areaFactors = areaFactors;\nexports.feature = feature;\nexports.geometry = geometry;\nexports.point = point;\nexports.points = points;\nexports.polygon = polygon;\nexports.polygons = polygons;\nexports.lineString = lineString;\nexports.lineStrings = lineStrings;\nexports.featureCollection = featureCollection;\nexports.multiLineString = multiLineString;\nexports.multiPoint = multiPoint;\nexports.multiPolygon = multiPolygon;\nexports.geometryCollection = geometryCollection;\nexports.round = round;\nexports.radiansToLength = radiansToLength;\nexports.lengthToRadians = lengthToRadians;\nexports.lengthToDegrees = lengthToDegrees;\nexports.bearingToAzimuth = bearingToAzimuth;\nexports.radiansToDegrees = radiansToDegrees;\nexports.degreesToRadians = degreesToRadians;\nexports.convertLength = convertLength;\nexports.convertArea = convertArea;\nexports.isNumber = isNumber;\nexports.isObject = isObject;\nexports.validateBBox = validateBBox;\nexports.validateId = validateId;\nexports.radians2degrees = radians2degrees;\nexports.degrees2radians = degrees2radians;\nexports.distanceToDegrees = distanceToDegrees;\nexports.distanceToRadians = distanceToRadians;\nexports.radiansToDistance = radiansToDistance;\nexports.bearingToAngle = bearingToAngle;\nexports.convertDistance = convertDistance;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(coord) {\n    if (!coord) throw new Error('coord is required');\n    if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') return coord.geometry.coordinates;\n    if (coord.type === 'Point') return coord.coordinates;\n    if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === undefined && coord[1].length === undefined) return coord;\n\n    throw new Error('coord must be GeoJSON Point or an Array of numbers');\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(coords) {\n    if (!coords) throw new Error('coords is required');\n\n    // Feature\n    if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n\n    // Geometry\n    if (coords.coordinates) return coords.coordinates;\n\n    // Array of numbers\n    if (Array.isArray(coords)) return coords;\n\n    throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 && helpers.isNumber(coordinates[0]) && helpers.isNumber(coordinates[1])) {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nfunction getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nfunction getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n\nexports.getCoord = getCoord;\nexports.getCoords = getCoords;\nexports.containsNumber = containsNumber;\nexports.geojsonType = geojsonType;\nexports.featureOf = featureOf;\nexports.collectionOf = collectionOf;\nexports.getGeom = getGeom;\nexports.getGeomType = getGeomType;\nexports.getType = getType;\n","'use strict';\n\n/**\n * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.\n * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.\n *\n * @name clone\n * @param {GeoJSON} geojson GeoJSON Object\n * @returns {GeoJSON} cloned GeoJSON Object\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});\n *\n * var lineCloned = turf.clone(line);\n */\nfunction clone(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n\n    switch (geojson.type) {\n    case 'Feature':\n        return cloneFeature(geojson);\n    case 'FeatureCollection':\n        return cloneFeatureCollection(geojson);\n    case 'Point':\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiPoint':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n    case 'GeometryCollection':\n        return cloneGeometry(geojson);\n    default:\n        throw new Error('unknown GeoJSON type');\n    }\n}\n\n/**\n * Clone Feature\n *\n * @private\n * @param {Feature<any>} geojson GeoJSON Feature\n * @returns {Feature<any>} cloned Feature\n */\nfunction cloneFeature(geojson) {\n    var cloned = {type: 'Feature'};\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n        case 'type':\n        case 'properties':\n        case 'geometry':\n            return;\n        default:\n            cloned[key] = geojson[key];\n        }\n    });\n    // Add properties & geometry last\n    cloned.properties = cloneProperties(geojson.properties);\n    cloned.geometry = cloneGeometry(geojson.geometry);\n    return cloned;\n}\n\n/**\n * Clone Properties\n *\n * @private\n * @param {Object} properties GeoJSON Properties\n * @returns {Object} cloned Properties\n */\nfunction cloneProperties(properties) {\n    var cloned = {};\n    if (!properties) return cloned;\n    Object.keys(properties).forEach(function (key) {\n        var value = properties[key];\n        if (typeof value === 'object') {\n            if (value === null) {\n                // handle null\n                cloned[key] = null;\n            } else if (value.length) {\n                // handle Array\n                cloned[key] = value.map(function (item) {\n                    return item;\n                });\n            } else {\n                // handle generic Object\n                cloned[key] = cloneProperties(value);\n            }\n        } else cloned[key] = value;\n    });\n    return cloned;\n}\n\n/**\n * Clone Feature Collection\n *\n * @private\n * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection\n * @returns {FeatureCollection<any>} cloned Feature Collection\n */\nfunction cloneFeatureCollection(geojson) {\n    var cloned = {type: 'FeatureCollection'};\n\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n        case 'type':\n        case 'features':\n            return;\n        default:\n            cloned[key] = geojson[key];\n        }\n    });\n    // Add features\n    cloned.features = geojson.features.map(function (feature) {\n        return cloneFeature(feature);\n    });\n    return cloned;\n}\n\n/**\n * Clone Geometry\n *\n * @private\n * @param {Geometry<any>} geometry GeoJSON Geometry\n * @returns {Geometry<any>} cloned Geometry\n */\nfunction cloneGeometry(geometry) {\n    var geom = {type: geometry.type};\n    if (geometry.bbox) geom.bbox = geometry.bbox;\n\n    if (geometry.type === 'GeometryCollection') {\n        geom.geometries = geometry.geometries.map(function (geom) {\n            return cloneGeometry(geom);\n        });\n        return geom;\n    }\n    geom.coordinates = deepSlice(geometry.coordinates);\n    return geom;\n}\n\n/**\n * Deep Slice coordinates\n *\n * @private\n * @param {Coordinates} coords Coordinates\n * @returns {Coordinates} all coordinates sliced\n */\nfunction deepSlice(coords) {\n    if (typeof coords[0] !== 'object') { return coords.slice(); }\n    return coords.map(function (coord) {\n        return deepSlice(coord);\n    });\n}\n\nmodule.exports = clone;\nmodule.exports.default = clone;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\n * degrees, radians, miles, or kilometers; and bearing in degrees.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nfunction destination(origin, distance, bearing, options) {\n    if (options === void 0) { options = {}; }\n    // Handle input\n    var coordinates1 = invariant_1.getCoord(origin);\n    var longitude1 = helpers_1.degreesToRadians(coordinates1[0]);\n    var latitude1 = helpers_1.degreesToRadians(coordinates1[1]);\n    var bearingRad = helpers_1.degreesToRadians(bearing);\n    var radians = helpers_1.lengthToRadians(distance, options.units);\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));\n    var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = helpers_1.radiansToDegrees(longitude2);\n    var lat = helpers_1.radiansToDegrees(latitude2);\n    return helpers_1.point([lng, lat], options.properties);\n}\nexports.default = destination;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant_1 = require(\"@turf/invariant\");\nvar helpers_1 = require(\"@turf/helpers\");\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name distance\n * @param {Coord} from origin point\n * @param {Coord} to destination point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    if (options === void 0) { options = {}; }\n    var coordinates1 = invariant_1.getCoord(from);\n    var coordinates2 = invariant_1.getCoord(to);\n    var dLat = helpers_1.degreesToRadians((coordinates2[1] - coordinates1[1]));\n    var dLon = helpers_1.degreesToRadians((coordinates2[0] - coordinates1[0]));\n    var lat1 = helpers_1.degreesToRadians(coordinates1[1]);\n    var lat2 = helpers_1.degreesToRadians(coordinates2[1]);\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n    return helpers_1.radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);\n}\nexports.default = distance;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"@turf/helpers\");\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\nvar line_segment_1 = __importDefault(require(\"@turf/line-segment\"));\nvar meta_1 = require(\"@turf/meta\");\nvar geojson_rbush_1 = __importDefault(require(\"geojson-rbush\"));\n/**\n * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).\n *\n * @name lineIntersect\n * @param {GeoJSON} line1 any LineString or Polygon\n * @param {GeoJSON} line2 any LineString or Polygon\n * @returns {FeatureCollection<Point>} point(s) that intersect both\n * @example\n * var line1 = turf.lineString([[126, -11], [129, -21]]);\n * var line2 = turf.lineString([[123, -18], [131, -14]]);\n * var intersects = turf.lineIntersect(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, intersects]\n */\nfunction lineIntersect(line1, line2) {\n    var unique = {};\n    var results = [];\n    // First, normalize geometries to features\n    // Then, handle simple 2-vertex segments\n    if (line1.type === \"LineString\") {\n        line1 = helpers_1.feature(line1);\n    }\n    if (line2.type === \"LineString\") {\n        line2 = helpers_1.feature(line2);\n    }\n    if (line1.type === \"Feature\" &&\n        line2.type === \"Feature\" &&\n        line1.geometry !== null &&\n        line2.geometry !== null &&\n        line1.geometry.type === \"LineString\" &&\n        line2.geometry.type === \"LineString\" &&\n        line1.geometry.coordinates.length === 2 &&\n        line2.geometry.coordinates.length === 2) {\n        var intersect = intersects(line1, line2);\n        if (intersect) {\n            results.push(intersect);\n        }\n        return helpers_1.featureCollection(results);\n    }\n    // Handles complex GeoJSON Geometries\n    var tree = geojson_rbush_1.default();\n    tree.load(line_segment_1.default(line2));\n    meta_1.featureEach(line_segment_1.default(line1), function (segment) {\n        meta_1.featureEach(tree.search(segment), function (match) {\n            var intersect = intersects(segment, match);\n            if (intersect) {\n                // prevent duplicate points https://github.com/Turfjs/turf/issues/688\n                var key = invariant_1.getCoords(intersect).join(\",\");\n                if (!unique[key]) {\n                    unique[key] = true;\n                    results.push(intersect);\n                }\n            }\n        });\n    });\n    return helpers_1.featureCollection(results);\n}\n/**\n * Find a point that intersects LineStrings with two coordinates each\n *\n * @private\n * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)\n * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)\n * @returns {Feature<Point>} intersecting GeoJSON Point\n */\nfunction intersects(line1, line2) {\n    var coords1 = invariant_1.getCoords(line1);\n    var coords2 = invariant_1.getCoords(line2);\n    if (coords1.length !== 2) {\n        throw new Error(\"<intersects> line1 must only contain 2 coordinates\");\n    }\n    if (coords2.length !== 2) {\n        throw new Error(\"<intersects> line2 must only contain 2 coordinates\");\n    }\n    var x1 = coords1[0][0];\n    var y1 = coords1[0][1];\n    var x2 = coords1[1][0];\n    var y2 = coords1[1][1];\n    var x3 = coords2[0][0];\n    var y3 = coords2[0][1];\n    var x4 = coords2[1][0];\n    var y4 = coords2[1][1];\n    var denom = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n    var numeA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n    var numeB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) {\n            return null;\n        }\n        return null;\n    }\n    var uA = numeA / denom;\n    var uB = numeB / denom;\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        var x = x1 + (uA * (x2 - x1));\n        var y = y1 + (uA * (y2 - y1));\n        return helpers_1.point([x, y]);\n    }\n    return null;\n}\nexports.default = lineIntersect;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar geojson_rbush_1 = require(\"geojson-rbush\");\nvar line_segment_1 = require(\"@turf/line-segment\");\nvar nearest_point_on_line_1 = require(\"@turf/nearest-point-on-line\");\nvar boolean_point_on_line_1 = require(\"@turf/boolean-point-on-line\");\nvar invariant_1 = require(\"@turf/invariant\");\nvar meta_1 = require(\"@turf/meta\");\nvar helpers_1 = require(\"@turf/helpers\");\nvar equal = require(\"deep-equal\");\n/**\n * Takes any LineString or Polygon and returns the overlapping lines between both features.\n *\n * @name lineOverlap\n * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon\n * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.tolerance=0] Tolerance distance to match overlapping line segments (in kilometers)\n * @returns {FeatureCollection<LineString>} lines(s) that are overlapping between both features\n * @example\n * var line1 = turf.lineString([[115, -35], [125, -30], [135, -30], [145, -35]]);\n * var line2 = turf.lineString([[115, -25], [125, -30], [135, -30], [145, -25]]);\n *\n * var overlapping = turf.lineOverlap(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, overlapping]\n */\nfunction lineOverlap(line1, line2, options) {\n    if (options === void 0) { options = {}; }\n    // Optional parameters\n    options = options || {};\n    if (!helpers_1.isObject(options))\n        throw new Error('options is invalid');\n    var tolerance = options.tolerance || 0;\n    // Containers\n    var features = [];\n    // Create Spatial Index\n    var tree = geojson_rbush_1.default();\n    // To-Do -- HACK way to support typescript\n    var line = line_segment_1.default(line1);\n    tree.load(line);\n    var overlapSegment;\n    // Line Intersection\n    // Iterate over line segments\n    meta_1.segmentEach(line2, function (segment) {\n        var doesOverlaps = false;\n        // Iterate over each segments which falls within the same bounds\n        meta_1.featureEach(tree.search(segment), function (match) {\n            if (doesOverlaps === false) {\n                var coordsSegment = invariant_1.getCoords(segment).sort();\n                var coordsMatch = invariant_1.getCoords(match).sort();\n                // Segment overlaps feature\n                if (equal(coordsSegment, coordsMatch)) {\n                    doesOverlaps = true;\n                    // Overlaps already exists - only append last coordinate of segment\n                    if (overlapSegment)\n                        overlapSegment = concatSegment(overlapSegment, segment);\n                    else\n                        overlapSegment = segment;\n                    // Match segments which don't share nodes (Issue #901)\n                }\n                else if ((tolerance === 0) ?\n                    boolean_point_on_line_1.default(coordsSegment[0], match) && boolean_point_on_line_1.default(coordsSegment[1], match) :\n                    nearest_point_on_line_1.default(match, coordsSegment[0]).properties.dist <= tolerance &&\n                        nearest_point_on_line_1.default(match, coordsSegment[1]).properties.dist <= tolerance) {\n                    doesOverlaps = true;\n                    if (overlapSegment)\n                        overlapSegment = concatSegment(overlapSegment, segment);\n                    else\n                        overlapSegment = segment;\n                }\n                else if ((tolerance === 0) ?\n                    boolean_point_on_line_1.default(coordsMatch[0], segment) && boolean_point_on_line_1.default(coordsMatch[1], segment) :\n                    nearest_point_on_line_1.default(segment, coordsMatch[0]).properties.dist <= tolerance &&\n                        nearest_point_on_line_1.default(segment, coordsMatch[1]).properties.dist <= tolerance) {\n                    // Do not define (doesOverlap = true) since more matches can occur within the same segment\n                    // doesOverlaps = true;\n                    if (overlapSegment)\n                        overlapSegment = concatSegment(overlapSegment, match);\n                    else\n                        overlapSegment = match;\n                }\n            }\n        });\n        // Segment doesn't overlap - add overlaps to results & reset\n        if (doesOverlaps === false && overlapSegment) {\n            features.push(overlapSegment);\n            overlapSegment = undefined;\n        }\n    });\n    // Add last segment if exists\n    if (overlapSegment)\n        features.push(overlapSegment);\n    return helpers_1.featureCollection(features);\n}\n/**\n * Concat Segment\n *\n * @private\n * @param {Feature<LineString>} line LineString\n * @param {Feature<LineString>} segment 2-vertex LineString\n * @returns {Feature<LineString>} concat linestring\n */\nfunction concatSegment(line, segment) {\n    var coords = invariant_1.getCoords(segment);\n    var lineCoords = invariant_1.getCoords(line);\n    var start = lineCoords[0];\n    var end = lineCoords[lineCoords.length - 1];\n    var geom = line.geometry.coordinates;\n    if (equal(coords[0], start))\n        geom.unshift(coords[1]);\n    else if (equal(coords[0], end))\n        geom.push(coords[1]);\n    else if (equal(coords[1], start))\n        geom.unshift(coords[0]);\n    else if (equal(coords[1], end))\n        geom.push(coords[0]);\n    return line;\n}\nexports.default = lineOverlap;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a\n * {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.\n *\n * @name lineSegment\n * @param {GeoJSON} geojson GeoJSON Polygon or LineString\n * @returns {FeatureCollection<LineString>} 2-vertex line segments\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n * var segments = turf.lineSegment(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, segments]\n */\nfunction lineSegment(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    var results = [];\n    meta_1.flattenEach(geojson, function (feature) {\n        lineSegmentFeature(feature, results);\n    });\n    return helpers_1.featureCollection(results);\n}\n/**\n * Line Segment\n *\n * @private\n * @param {Feature<LineString|Polygon>} geojson Line or polygon feature\n * @param {Array} results push to results\n * @returns {void}\n */\nfunction lineSegmentFeature(geojson, results) {\n    var coords = [];\n    var geometry = geojson.geometry;\n    if (geometry !== null) {\n        switch (geometry.type) {\n            case \"Polygon\":\n                coords = invariant_1.getCoords(geometry);\n                break;\n            case \"LineString\":\n                coords = [invariant_1.getCoords(geometry)];\n        }\n        coords.forEach(function (coord) {\n            var segments = createSegments(coord, geojson.properties);\n            segments.forEach(function (segment) {\n                segment.id = results.length;\n                results.push(segment);\n            });\n        });\n    }\n}\n/**\n * Create Segments from LineString coordinates\n *\n * @private\n * @param {Array<Array<number>>} coords LineString coordinates\n * @param {*} properties GeoJSON properties\n * @returns {Array<Feature<LineString>>} line segments\n */\nfunction createSegments(coords, properties) {\n    var segments = [];\n    coords.reduce(function (previousCoords, currentCoords) {\n        var segment = helpers_1.lineString([previousCoords, currentCoords], properties);\n        segment.bbox = bbox(previousCoords, currentCoords);\n        segments.push(segment);\n        return currentCoords;\n    });\n    return segments;\n}\n/**\n * Create BBox between two coordinates (faster than @turf/bbox)\n *\n * @private\n * @param {Array<number>} coords1 Point coordinate\n * @param {Array<number>} coords2 Point coordinate\n * @returns {BBox} [west, south, east, north]\n */\nfunction bbox(coords1, coords2) {\n    var x1 = coords1[0];\n    var y1 = coords1[1];\n    var x2 = coords2[0];\n    var y2 = coords2[1];\n    var west = (x1 < x2) ? x1 : x2;\n    var south = (y1 < y2) ? y1 : y2;\n    var east = (x1 > x2) ? x1 : x2;\n    var north = (y1 > y2) ? y1 : y2;\n    return [west, south, east, north];\n}\nexports.default = lineSegment;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bearing_1 = require(\"@turf/bearing\");\nvar distance_1 = require(\"@turf/distance\");\nvar destination_1 = require(\"@turf/destination\");\nvar line_intersect_1 = require(\"@turf/line-intersect\");\nvar meta_1 = require(\"@turf/meta\");\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.\n *\n * @name nearestPointOnLine\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var pt = turf.point([-77.037076, 38.884017]);\n *\n * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, pt, snapped];\n * snapped.properties['marker-color'] = '#00f';\n */\nfunction nearestPointOnLine(lines, pt, options) {\n    if (options === void 0) { options = {}; }\n    var closestPt = helpers_1.point([Infinity, Infinity], {\n        dist: Infinity\n    });\n    var length = 0.0;\n    meta_1.flattenEach(lines, function (line) {\n        var coords = invariant_1.getCoords(line);\n        for (var i = 0; i < coords.length - 1; i++) {\n            //start\n            var start = helpers_1.point(coords[i]);\n            start.properties.dist = distance_1.default(pt, start, options);\n            //stop\n            var stop_1 = helpers_1.point(coords[i + 1]);\n            stop_1.properties.dist = distance_1.default(pt, stop_1, options);\n            // sectionLength\n            var sectionLength = distance_1.default(start, stop_1, options);\n            //perpendicular\n            var heightDistance = Math.max(start.properties.dist, stop_1.properties.dist);\n            var direction = bearing_1.default(start, stop_1);\n            var perpendicularPt1 = destination_1.default(pt, heightDistance, direction + 90, options);\n            var perpendicularPt2 = destination_1.default(pt, heightDistance, direction - 90, options);\n            var intersect = line_intersect_1.default(helpers_1.lineString([perpendicularPt1.geometry.coordinates, perpendicularPt2.geometry.coordinates]), helpers_1.lineString([start.geometry.coordinates, stop_1.geometry.coordinates]));\n            var intersectPt = null;\n            if (intersect.features.length > 0) {\n                intersectPt = intersect.features[0];\n                intersectPt.properties.dist = distance_1.default(pt, intersectPt, options);\n                intersectPt.properties.location = length + distance_1.default(start, intersectPt, options);\n            }\n            if (start.properties.dist < closestPt.properties.dist) {\n                closestPt = start;\n                closestPt.properties.index = i;\n                closestPt.properties.location = length;\n            }\n            if (stop_1.properties.dist < closestPt.properties.dist) {\n                closestPt = stop_1;\n                closestPt.properties.index = i + 1;\n                closestPt.properties.location = length + sectionLength;\n            }\n            if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n                closestPt = intersectPt;\n                closestPt.properties.index = i;\n            }\n            // update length\n            length += sectionLength;\n        }\n    });\n    return closestPt;\n}\nexports.default = nearestPointOnLine;\n","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar cleanCoords = _interopDefault(require('@turf/clean-coords'));\nvar clone = _interopDefault(require('@turf/clone'));\nvar meta = require('@turf/meta');\nvar helpers = require('@turf/helpers');\n\n/*\n (c) 2013, Vladimir Agafonkin\n Simplify.js, a high-performance JS polyline simplification library\n mourner.github.io/simplify-js\n*/\n\n// to suit your point format, run search/replace for '.x' and '.y';\n// for 3D version, see 3d branch (configurability would draw significant performance overhead)\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n\n    var dx = p1.x - p2.x,\n        dy = p1.y - p2.y;\n\n    return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(p, p1, p2) {\n\n    var x = p1.x,\n        y = p1.y,\n        dx = p2.x - x,\n        dy = p2.y - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = p2.x;\n            y = p2.y;\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = p.x - x;\n    dy = p.y - y;\n\n    return dx * dx + dy * dy;\n}\n// rest of the code doesn't care about point format\n\n// basic distance-based simplification\nfunction simplifyRadialDist(points, sqTolerance) {\n\n    var prevPoint = points[0],\n        newPoints = [prevPoint],\n        point;\n\n    for (var i = 1, len = points.length; i < len; i++) {\n        point = points[i];\n\n        if (getSqDist(point, prevPoint) > sqTolerance) {\n            newPoints.push(point);\n            prevPoint = point;\n        }\n    }\n\n    if (prevPoint !== point) newPoints.push(point);\n\n    return newPoints;\n}\n\nfunction simplifyDPStep(points, first, last, sqTolerance, simplified) {\n    var maxSqDist = sqTolerance,\n        index;\n\n    for (var i = first + 1; i < last; i++) {\n        var sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n        if (sqDist > maxSqDist) {\n            index = i;\n            maxSqDist = sqDist;\n        }\n    }\n\n    if (maxSqDist > sqTolerance) {\n        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);\n        simplified.push(points[index]);\n        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n}\n\n// simplification using Ramer-Douglas-Peucker algorithm\nfunction simplifyDouglasPeucker(points, sqTolerance) {\n    var last = points.length - 1;\n\n    var simplified = [points[0]];\n    simplifyDPStep(points, 0, last, sqTolerance, simplified);\n    simplified.push(points[last]);\n\n    return simplified;\n}\n\n// both algorithms combined for awesome performance\nfunction simplify$2(points, tolerance, highestQuality) {\n\n    if (points.length <= 2) return points;\n\n    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n\n    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n    points = simplifyDouglasPeucker(points, sqTolerance);\n\n    return points;\n}\n\n/**\n * Takes a {@link GeoJSON} object and returns a simplified version. Internally uses\n * [simplify-js](http://mourner.github.io/simplify-js/) to perform simplification using the Ramer-Douglas-Peucker algorithm.\n *\n * @name simplify\n * @param {GeoJSON} geojson object to be simplified\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.tolerance=1] simplification tolerance\n * @param {boolean} [options.highQuality=false] whether or not to spend more time to create a higher-quality simplification with a different algorithm\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} a simplified GeoJSON\n * @example\n * var geojson = turf.polygon([[\n *   [-70.603637, -33.399918],\n *   [-70.614624, -33.395332],\n *   [-70.639343, -33.392466],\n *   [-70.659942, -33.394759],\n *   [-70.683975, -33.404504],\n *   [-70.697021, -33.419406],\n *   [-70.701141, -33.434306],\n *   [-70.700454, -33.446339],\n *   [-70.694274, -33.458369],\n *   [-70.682601, -33.465816],\n *   [-70.668869, -33.472117],\n *   [-70.646209, -33.473835],\n *   [-70.624923, -33.472117],\n *   [-70.609817, -33.468107],\n *   [-70.595397, -33.458369],\n *   [-70.587158, -33.442901],\n *   [-70.587158, -33.426283],\n *   [-70.590591, -33.414248],\n *   [-70.594711, -33.406224],\n *   [-70.603637, -33.399918]\n * ]]);\n * var options = {tolerance: 0.01, highQuality: false};\n * var simplified = turf.simplify(geojson, options);\n *\n * //addToMap\n * var addToMap = [geojson, simplified]\n */\nfunction simplify(geojson, options) {\n    // Optional parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var tolerance = options.tolerance !== undefined ? options.tolerance : 1;\n    var highQuality = options.highQuality || false;\n    var mutate = options.mutate || false;\n\n    if (!geojson) throw new Error('geojson is required');\n    if (tolerance && tolerance < 0) throw new Error('invalid tolerance');\n\n    // Clone geojson to avoid side effects\n    if (mutate !== true) geojson = clone(geojson);\n\n    meta.geomEach(geojson, function (geom) {\n        simplifyGeom(geom, tolerance, highQuality);\n    });\n    return geojson;\n}\n\n/**\n * Simplifies a feature's coordinates\n *\n * @private\n * @param {Geometry} geometry to be simplified\n * @param {number} [tolerance=1] simplification tolerance\n * @param {boolean} [highQuality=false] whether or not to spend more time to create a higher-quality simplification with a different algorithm\n * @returns {Geometry} output\n */\nfunction simplifyGeom(geometry, tolerance, highQuality) {\n    var type = geometry.type;\n\n    // \"unsimplyfiable\" geometry types\n    if (type === 'Point' || type === 'MultiPoint') return geometry;\n\n    // Remove any extra coordinates\n    cleanCoords(geometry, true);\n\n    var coordinates = geometry.coordinates;\n    switch (type) {\n    case 'LineString':\n        geometry['coordinates'] = simplifyLine(coordinates, tolerance, highQuality);\n        break;\n    case 'MultiLineString':\n        geometry['coordinates'] = coordinates.map(function (lines) {\n            return simplifyLine(lines, tolerance, highQuality);\n        });\n        break;\n    case 'Polygon':\n        geometry['coordinates'] = simplifyPolygon(coordinates, tolerance, highQuality);\n        break;\n    case 'MultiPolygon':\n        geometry['coordinates'] = coordinates.map(function (rings) {\n            return simplifyPolygon(rings, tolerance, highQuality);\n        });\n    }\n    return geometry;\n}\n\n\n/**\n * Simplifies the coordinates of a LineString with simplify-js\n *\n * @private\n * @param {Array<number>} coordinates to be processed\n * @param {number} tolerance simplification tolerance\n * @param {boolean} highQuality whether or not to spend more time to create a higher-quality\n * @returns {Array<Array<number>>} simplified coords\n */\nfunction simplifyLine(coordinates, tolerance, highQuality) {\n    return simplify$2(coordinates.map(function (coord) {\n        return {x: coord[0], y: coord[1], z: coord[2]};\n    }), tolerance, highQuality).map(function (coords) {\n        return (coords.z) ? [coords.x, coords.y, coords.z] : [coords.x, coords.y];\n    });\n}\n\n\n/**\n * Simplifies the coordinates of a Polygon with simplify-js\n *\n * @private\n * @param {Array<number>} coordinates to be processed\n * @param {number} tolerance simplification tolerance\n * @param {boolean} highQuality whether or not to spend more time to create a higher-quality\n * @returns {Array<Array<Array<number>>>} simplified coords\n */\nfunction simplifyPolygon(coordinates, tolerance, highQuality) {\n    return coordinates.map(function (ring) {\n        var pts = ring.map(function (coord) {\n            return {x: coord[0], y: coord[1]};\n        });\n        if (pts.length < 4) {\n            throw new Error('invalid polygon');\n        }\n        var simpleRing = simplify$2(pts, tolerance, highQuality).map(function (coords) {\n            return [coords.x, coords.y];\n        });\n        //remove 1 percent of tolerance until enough points to make a triangle\n        while (!checkValidity(simpleRing)) {\n            tolerance -= tolerance * 0.01;\n            simpleRing = simplify$2(pts, tolerance, highQuality).map(function (coords) {\n                return [coords.x, coords.y];\n            });\n        }\n        if (\n            (simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0]) ||\n            (simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1])) {\n            simpleRing.push(simpleRing[0]);\n        }\n        return simpleRing;\n    });\n}\n\n\n/**\n * Returns true if ring has at least 3 coordinates and its first coordinate is the same as its last\n *\n * @private\n * @param {Array<number>} ring coordinates to be checked\n * @returns {boolean} true if valid\n */\nfunction checkValidity(ring) {\n    if (ring.length < 3) return false;\n    //if the last point is the same as the first, it's not a triangle\n    return !(ring.length === 3 && ((ring[2][0] === ring[0][0]) && (ring[2][1] === ring[0][1])));\n}\n\nmodule.exports = simplify;\nmodule.exports.default = simplify;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined) {\n                previousCoords = currentCoord;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature$$1.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","var objectKeys = require('object-keys');\nvar isArguments = require('is-arguments');\nvar is = require('object-is');\nvar isRegex = require('is-regex');\nvar flags = require('regexp.prototype.flags');\nvar isDate = require('is-date-object');\n\nvar getTime = Date.prototype.getTime;\n\nfunction deepEqual(actual, expected, options) {\n  var opts = options || {};\n\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (opts.strict ? is(actual, expected) : actual === expected) {\n    return true;\n  }\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.\n  if (!actual || !expected || (typeof actual !== 'object' && typeof expected !== 'object')) {\n    return opts.strict ? is(actual, expected) : actual == expected;\n  }\n\n  /*\n   * 7.4. For all other Object pairs, including Array objects, equivalence is\n   * determined by having the same number of owned properties (as verified\n   * with Object.prototype.hasOwnProperty.call), the same set of keys\n   * (although not necessarily the same order), equivalent values for every\n   * corresponding key, and an identical 'prototype' property. Note: this\n   * accounts for both named and indexed properties on Arrays.\n   */\n  // eslint-disable-next-line no-use-before-define\n  return objEquiv(actual, expected, opts);\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer(x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') {\n    return false;\n  }\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') {\n    return false;\n  }\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  /* eslint max-statements: [2, 50] */\n  var i, key;\n  if (typeof a !== typeof b) { return false; }\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) { return false; }\n\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) { return false; }\n\n  if (isArguments(a) !== isArguments(b)) { return false; }\n\n  var aIsRegex = isRegex(a);\n  var bIsRegex = isRegex(b);\n  if (aIsRegex !== bIsRegex) { return false; }\n  if (aIsRegex || bIsRegex) {\n    return a.source === b.source && flags(a) === flags(b);\n  }\n\n  if (isDate(a) && isDate(b)) {\n    return getTime.call(a) === getTime.call(b);\n  }\n\n  var aIsBuffer = isBuffer(a);\n  var bIsBuffer = isBuffer(b);\n  if (aIsBuffer !== bIsBuffer) { return false; }\n  if (aIsBuffer || bIsBuffer) { // && would work too, because both are true or both false here\n    if (a.length !== b.length) { return false; }\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) { return false; }\n    }\n    return true;\n  }\n\n  if (typeof a !== typeof b) { return false; }\n\n  try {\n    var ka = objectKeys(a);\n    var kb = objectKeys(b);\n  } catch (e) { // happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates hasOwnProperty)\n  if (ka.length !== kb.length) { return false; }\n\n  // the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  // ~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i]) { return false; }\n  }\n  // equivalent values for every corresponding key, and ~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) { return false; }\n  }\n\n  return true;\n}\n\nmodule.exports = deepEqual;\n","'use strict';\n\nvar keys = require('object-keys');\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';\n\nvar toStr = Object.prototype.toString;\nvar concat = Array.prototype.concat;\nvar origDefineProperty = Object.defineProperty;\n\nvar isFunction = function (fn) {\n\treturn typeof fn === 'function' && toStr.call(fn) === '[object Function]';\n};\n\nvar arePropertyDescriptorsSupported = function () {\n\tvar obj = {};\n\ttry {\n\t\torigDefineProperty(obj, 'x', { enumerable: false, value: obj });\n\t\t// eslint-disable-next-line no-unused-vars, no-restricted-syntax\n\t\tfor (var _ in obj) { // jscs:ignore disallowUnusedVariables\n\t\t\treturn false;\n\t\t}\n\t\treturn obj.x === obj;\n\t} catch (e) { /* this is IE 8. */\n\t\treturn false;\n\t}\n};\nvar supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();\n\nvar defineProperty = function (object, name, value, predicate) {\n\tif (name in object && (!isFunction(predicate) || !predicate())) {\n\t\treturn;\n\t}\n\tif (supportsDescriptors) {\n\t\torigDefineProperty(object, name, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: value,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\tobject[name] = value;\n\t}\n};\n\nvar defineProperties = function (object, map) {\n\tvar predicates = arguments.length > 2 ? arguments[2] : {};\n\tvar props = keys(map);\n\tif (hasSymbols) {\n\t\tprops = concat.call(props, Object.getOwnPropertySymbols(map));\n\t}\n\tfor (var i = 0; i < props.length; i += 1) {\n\t\tdefineProperty(object, props[i], map[props[i]], predicates[props[i]]);\n\t}\n};\n\ndefineProperties.supportsDescriptors = !!supportsDescriptors;\n\nmodule.exports = defineProperties;\n","'use strict';\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = Function.prototype.bind || implementation;\n","//index.js\nvar deepEqual = require('deep-equal');\n\nvar Equality = function(opt) {\n  this.precision = opt && opt.precision ? opt.precision : 17;\n  this.direction = opt && opt.direction ? opt.direction : false;\n  this.pseudoNode = opt && opt.pseudoNode ? opt.pseudoNode : false;\n  this.objectComparator = opt && opt.objectComparator ? opt.objectComparator : objectComparator;\n};\n\nEquality.prototype.compare = function(g1,g2) {\n  if (g1.type !== g2.type || !sameLength(g1,g2)) return false;\n\n  switch(g1.type) {\n  case 'Point':\n    return this.compareCoord(g1.coordinates, g2.coordinates);\n    break;\n  case 'LineString':\n    return this.compareLine(g1.coordinates, g2.coordinates,0,false);\n    break;\n  case 'Polygon':\n    return this.comparePolygon(g1,g2);\n    break;\n  case 'Feature':\n    return this.compareFeature(g1, g2);\n  default:\n    if (g1.type.indexOf('Multi') === 0) {\n      var context = this;\n      var g1s = explode(g1);\n      var g2s = explode(g2);\n      return g1s.every(function(g1part) {\n        return this.some(function(g2part) {\n          return context.compare(g1part,g2part);\n        });\n      },g2s);\n    }\n  }\n  return false;\n};\n\nfunction explode(g) {\n  return g.coordinates.map(function(part) {\n    return {\n      type: g.type.replace('Multi', ''),\n      coordinates: part}\n  });\n}\n//compare length of coordinates/array\nfunction sameLength(g1,g2) {\n   return g1.hasOwnProperty('coordinates') ?\n    g1.coordinates.length === g2.coordinates.length\n    : g1.length === g2.length;\n}\n\n// compare the two coordinates [x,y]\nEquality.prototype.compareCoord = function(c1,c2) {\n  if (c1.length !== c2.length) {\n    return false;\n  }\n\n  for (var i=0; i < c1.length; i++) {\n    if (c1[i].toFixed(this.precision) !== c2[i].toFixed(this.precision)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nEquality.prototype.compareLine = function(path1,path2,ind,isPoly) {\n  if (!sameLength(path1,path2)) return false;\n  var p1 = this.pseudoNode ? path1 : this.removePseudo(path1);\n  var p2 = this.pseudoNode ? path2 : this.removePseudo(path2);\n  if (isPoly && !this.compareCoord(p1[0],p2[0])) {\n    // fix start index of both to same point\n    p2 = this.fixStartIndex(p2,p1);\n    if(!p2) return;\n  }\n  // for linestring ind =0 and for polygon ind =1\n  var sameDirection = this.compareCoord(p1[ind],p2[ind]);\n  if (this.direction || sameDirection\n  ) {\n    return this.comparePath(p1, p2);\n  } else {\n    if (this.compareCoord(p1[ind],p2[p2.length - (1+ind)])\n    ) {\n      return this.comparePath(p1.slice().reverse(), p2);\n    }\n    return false;\n  }\n};\nEquality.prototype.fixStartIndex = function(sourcePath,targetPath) {\n  //make sourcePath first point same as of targetPath\n  var correctPath,ind = -1;\n  for (var i=0; i< sourcePath.length; i++) {\n    if(this.compareCoord(sourcePath[i],targetPath[0])) {\n      ind = i;\n      break;\n    }\n  }\n  if (ind >= 0) {\n    correctPath = [].concat(\n      sourcePath.slice(ind,sourcePath.length),\n      sourcePath.slice(1,ind+1));\n  }\n  return correctPath;\n};\nEquality.prototype.comparePath = function (p1,p2) {\n  var cont = this;\n  return p1.every(function(c,i) {\n    return cont.compareCoord(c,this[i]);\n  },p2);\n};\n\nEquality.prototype.comparePolygon = function(g1,g2) {\n  if (this.compareLine(g1.coordinates[0],g2.coordinates[0],1,true)) {\n    var holes1 = g1.coordinates.slice(1,g1.coordinates.length);\n    var holes2 = g2.coordinates.slice(1,g2.coordinates.length);\n    var cont = this;\n    return holes1.every(function(h1) {\n      return this.some(function(h2) {\n        return cont.compareLine(h1,h2,1,true);\n      });\n    },holes2);\n  } else {\n    return false;\n  }\n};\n\nEquality.prototype.compareFeature = function(g1,g2) {\n  if (\n    g1.id !== g2.id ||\n    !this.objectComparator(g1.properties, g2.properties) ||\n    !this.compareBBox(g1,g2)\n  ) {\n    return false;\n  }\n  return this.compare(g1.geometry, g2.geometry);\n};\n\nEquality.prototype.compareBBox = function(g1,g2) {\n  if (\n    (!g1.bbox && !g2.bbox) || \n    (\n      g1.bbox && g2.bbox &&\n      this.compareCoord(g1.bbox, g2.bbox)\n    )\n  )  {\n    return true;\n  }\n  return false;\n};\nEquality.prototype.removePseudo = function(path) {\n  //TODO to be implement\n  return path;\n};\n\nfunction objectComparator(obj1, obj2) {\n  return deepEqual(obj1, obj2, {strict: true});\n}\n\nmodule.exports = Equality;\n","var rbush = require('rbush');\nvar helpers = require('@turf/helpers');\nvar meta = require('@turf/meta');\nvar turfBBox = require('@turf/bbox').default;\nvar featureEach = meta.featureEach;\nvar coordEach = meta.coordEach;\nvar polygon = helpers.polygon;\nvar featureCollection = helpers.featureCollection;\n\n/**\n * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.\n *\n * @name rbush\n * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a\n * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.\n * @returns {RBush} GeoJSON RBush\n * @example\n * var geojsonRbush = require('geojson-rbush').default;\n * var tree = geojsonRbush();\n */\nfunction geojsonRbush(maxEntries) {\n    var tree = rbush(maxEntries);\n    /**\n     * [insert](https://github.com/mourner/rbush#data-format)\n     *\n     * @param {Feature} feature insert single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     * tree.insert(poly)\n     */\n    tree.insert = function (feature) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.insert.call(this, feature);\n    };\n\n    /**\n     * [load](https://github.com/mourner/rbush#bulk-inserting-data)\n     *\n     * @param {FeatureCollection|Array<Feature>} features load entire GeoJSON FeatureCollection\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polys = turf.polygons([\n     *     [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]],\n     *     [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]\n     * ]);\n     * tree.load(polys);\n     */\n    tree.load = function (features) {\n        var load = [];\n        // Load an Array of Features\n        if (Array.isArray(features)) {\n            features.forEach(function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        } else {\n            // Load a FeatureCollection\n            featureEach(features, function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        }\n        return rbush.prototype.load.call(this, load);\n    };\n\n    /**\n     * [remove](https://github.com/mourner/rbush#removing-data)\n     *\n     * @param {Feature} feature remove single GeoJSON Feature\n     * @param {Function} equals Pass a custom equals function to compare by value for removal.\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.remove(poly);\n     */\n    tree.remove = function (feature, equals) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.remove.call(this, feature, equals);\n    };\n\n    /**\n     * [clear](https://github.com/mourner/rbush#removing-data)\n     *\n     * @returns {RBush} GeoJSON Rbush\n     * @example\n     * tree.clear()\n     */\n    tree.clear = function () {\n        return rbush.prototype.clear.call(this);\n    };\n\n    /**\n     * [search](https://github.com/mourner/rbush#search)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson search with GeoJSON\n     * @returns {FeatureCollection} all features that intersects with the given GeoJSON.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.search(poly);\n     */\n    tree.search = function (geojson) {\n        var features = rbush.prototype.search.call(this, this.toBBox(geojson));\n        return featureCollection(features);\n    };\n\n    /**\n     * [collides](https://github.com/mourner/rbush#collisions)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson collides with GeoJSON\n     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.collides(poly);\n     */\n    tree.collides = function (geojson) {\n        return rbush.prototype.collides.call(this, this.toBBox(geojson));\n    };\n\n    /**\n     * [all](https://github.com/mourner/rbush#search)\n     *\n     * @returns {FeatureCollection} all the features in RBush\n     * @example\n     * tree.all()\n     */\n    tree.all = function () {\n        var features = rbush.prototype.all.call(this);\n        return featureCollection(features);\n    };\n\n    /**\n     * [toJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @returns {any} export data as JSON object\n     * @example\n     * var exported = tree.toJSON()\n     */\n    tree.toJSON = function () {\n        return rbush.prototype.toJSON.call(this);\n    };\n\n    /**\n     * [fromJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @param {any} json import previously exported data\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var exported = {\n     *   \"children\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"geometry\": {\n     *         \"type\": \"Point\",\n     *         \"coordinates\": [110, 50]\n     *       },\n     *       \"properties\": {},\n     *       \"bbox\": [110, 50, 110, 50]\n     *     }\n     *   ],\n     *   \"height\": 1,\n     *   \"leaf\": true,\n     *   \"minX\": 110,\n     *   \"minY\": 50,\n     *   \"maxX\": 110,\n     *   \"maxY\": 50\n     * }\n     * tree.fromJSON(exported)\n     */\n    tree.fromJSON = function (json) {\n        return rbush.prototype.fromJSON.call(this, json);\n    };\n\n    /**\n     * Converts GeoJSON to {minX, minY, maxX, maxY} schema\n     *\n     * @private\n     * @param {BBox|FeatureCollection|Feature} geojson feature(s) to retrieve BBox from\n     * @returns {Object} converted to {minX, minY, maxX, maxY}\n     */\n    tree.toBBox = function (geojson) {\n        var bbox;\n        if (geojson.bbox) bbox = geojson.bbox;\n        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;\n        else if (Array.isArray(geojson) && geojson.length === 6) bbox = [geojson[0], geojson[1], geojson[3], geojson[4]];\n        else if (geojson.type === 'Feature') bbox = turfBBox(geojson);\n        else if (geojson.type === 'FeatureCollection') bbox = turfBBox(geojson);\n        else throw new Error('invalid geojson')\n\n        return {\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        };\n    };\n    return tree;\n}\n\nmodule.exports = geojsonRbush;\nmodule.exports.default = geojsonRbush;\n","'use strict';\n\nvar bind = require('function-bind');\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n","'use strict';\n\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\nvar toStr = Object.prototype.toString;\n\nvar isStandardArguments = function isArguments(value) {\n\tif (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {\n\t\treturn false;\n\t}\n\treturn toStr.call(value) === '[object Arguments]';\n};\n\nvar isLegacyArguments = function isArguments(value) {\n\tif (isStandardArguments(value)) {\n\t\treturn true;\n\t}\n\treturn value !== null &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.length === 'number' &&\n\t\tvalue.length >= 0 &&\n\t\ttoStr.call(value) !== '[object Array]' &&\n\t\ttoStr.call(value.callee) === '[object Function]';\n};\n\nvar supportsStandardArguments = (function () {\n\treturn isStandardArguments(arguments);\n}());\n\nisStandardArguments.isLegacyArguments = isLegacyArguments; // for tests\n\nmodule.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;\n","'use strict';\n\nvar getDay = Date.prototype.getDay;\nvar tryDateObject = function tryDateObject(value) {\n\ttry {\n\t\tgetDay.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n\nvar toStr = Object.prototype.toString;\nvar dateClass = '[object Date]';\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nmodule.exports = function isDateObject(value) {\n\tif (typeof value !== 'object' || value === null) { return false; }\n\treturn hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;\n};\n","'use strict';\n\nvar has = require('has');\nvar regexExec = RegExp.prototype.exec;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar tryRegexExecCall = function tryRegexExec(value) {\n\ttry {\n\t\tvar lastIndex = value.lastIndex;\n\t\tvalue.lastIndex = 0;\n\n\t\tregexExec.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\tvalue.lastIndex = lastIndex;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar regexClass = '[object RegExp]';\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nmodule.exports = function isRegex(value) {\n\tif (!value || typeof value !== 'object') {\n\t\treturn false;\n\t}\n\tif (!hasToStringTag) {\n\t\treturn toStr.call(value) === regexClass;\n\t}\n\n\tvar descriptor = gOPD(value, 'lastIndex');\n\tvar hasLastIndexDataProperty = descriptor && has(descriptor, 'value');\n\tif (!hasLastIndexDataProperty) {\n\t\treturn false;\n\t}\n\n\treturn tryRegexExecCall(value);\n};\n","\"use strict\";\n\n/* https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.is */\n\nvar NumberIsNaN = function (value) {\n\treturn value !== value;\n};\n\nmodule.exports = function is(a, b) {\n\tif (a === 0 && b === 0) {\n\t\treturn 1 / a === 1 / b;\n\t} else if (a === b) {\n\t\treturn true;\n\t} else if (NumberIsNaN(a) && NumberIsNaN(b)) {\n\t\treturn true;\n\t}\n\treturn false;\n};\n\n","'use strict';\n\nvar keysShim;\nif (!Object.keys) {\n\t// modified from https://github.com/es-shims/es5-shim\n\tvar has = Object.prototype.hasOwnProperty;\n\tvar toStr = Object.prototype.toString;\n\tvar isArgs = require('./isArguments'); // eslint-disable-line global-require\n\tvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\tvar hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');\n\tvar hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');\n\tvar dontEnums = [\n\t\t'toString',\n\t\t'toLocaleString',\n\t\t'valueOf',\n\t\t'hasOwnProperty',\n\t\t'isPrototypeOf',\n\t\t'propertyIsEnumerable',\n\t\t'constructor'\n\t];\n\tvar equalsConstructorPrototype = function (o) {\n\t\tvar ctor = o.constructor;\n\t\treturn ctor && ctor.prototype === o;\n\t};\n\tvar excludedKeys = {\n\t\t$applicationCache: true,\n\t\t$console: true,\n\t\t$external: true,\n\t\t$frame: true,\n\t\t$frameElement: true,\n\t\t$frames: true,\n\t\t$innerHeight: true,\n\t\t$innerWidth: true,\n\t\t$onmozfullscreenchange: true,\n\t\t$onmozfullscreenerror: true,\n\t\t$outerHeight: true,\n\t\t$outerWidth: true,\n\t\t$pageXOffset: true,\n\t\t$pageYOffset: true,\n\t\t$parent: true,\n\t\t$scrollLeft: true,\n\t\t$scrollTop: true,\n\t\t$scrollX: true,\n\t\t$scrollY: true,\n\t\t$self: true,\n\t\t$webkitIndexedDB: true,\n\t\t$webkitStorageInfo: true,\n\t\t$window: true\n\t};\n\tvar hasAutomationEqualityBug = (function () {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined') { return false; }\n\t\tfor (var k in window) {\n\t\t\ttry {\n\t\t\t\tif (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tequalsConstructorPrototype(window[k]);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}());\n\tvar equalsConstructorPrototypeIfNotBuggy = function (o) {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined' || !hasAutomationEqualityBug) {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t}\n\t\ttry {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tkeysShim = function keys(object) {\n\t\tvar isObject = object !== null && typeof object === 'object';\n\t\tvar isFunction = toStr.call(object) === '[object Function]';\n\t\tvar isArguments = isArgs(object);\n\t\tvar isString = isObject && toStr.call(object) === '[object String]';\n\t\tvar theKeys = [];\n\n\t\tif (!isObject && !isFunction && !isArguments) {\n\t\t\tthrow new TypeError('Object.keys called on a non-object');\n\t\t}\n\n\t\tvar skipProto = hasProtoEnumBug && isFunction;\n\t\tif (isString && object.length > 0 && !has.call(object, 0)) {\n\t\t\tfor (var i = 0; i < object.length; ++i) {\n\t\t\t\ttheKeys.push(String(i));\n\t\t\t}\n\t\t}\n\n\t\tif (isArguments && object.length > 0) {\n\t\t\tfor (var j = 0; j < object.length; ++j) {\n\t\t\t\ttheKeys.push(String(j));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var name in object) {\n\t\t\t\tif (!(skipProto && name === 'prototype') && has.call(object, name)) {\n\t\t\t\t\ttheKeys.push(String(name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (hasDontEnumBug) {\n\t\t\tvar skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\n\n\t\t\tfor (var k = 0; k < dontEnums.length; ++k) {\n\t\t\t\tif (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {\n\t\t\t\t\ttheKeys.push(dontEnums[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theKeys;\n\t};\n}\nmodule.exports = keysShim;\n","'use strict';\n\nvar slice = Array.prototype.slice;\nvar isArgs = require('./isArguments');\n\nvar origKeys = Object.keys;\nvar keysShim = origKeys ? function keys(o) { return origKeys(o); } : require('./implementation');\n\nvar originalKeys = Object.keys;\n\nkeysShim.shim = function shimObjectKeys() {\n\tif (Object.keys) {\n\t\tvar keysWorksWithArguments = (function () {\n\t\t\t// Safari 5.0 bug\n\t\t\tvar args = Object.keys(arguments);\n\t\t\treturn args && args.length === arguments.length;\n\t\t}(1, 2));\n\t\tif (!keysWorksWithArguments) {\n\t\t\tObject.keys = function keys(object) { // eslint-disable-line func-name-matching\n\t\t\t\tif (isArgs(object)) {\n\t\t\t\t\treturn originalKeys(slice.call(object));\n\t\t\t\t}\n\t\t\t\treturn originalKeys(object);\n\t\t\t};\n\t\t}\n\t} else {\n\t\tObject.keys = keysShim;\n\t}\n\treturn Object.keys || keysShim;\n};\n\nmodule.exports = keysShim;\n","'use strict';\n\nvar toStr = Object.prototype.toString;\n\nmodule.exports = function isArguments(value) {\n\tvar str = toStr.call(value);\n\tvar isArgs = str === '[object Arguments]';\n\tif (!isArgs) {\n\t\tisArgs = str !== '[object Array]' &&\n\t\t\tvalue !== null &&\n\t\t\ttypeof value === 'object' &&\n\t\t\ttypeof value.length === 'number' &&\n\t\t\tvalue.length >= 0 &&\n\t\t\ttoStr.call(value.callee) === '[object Function]';\n\t}\n\treturn isArgs;\n};\n","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.quickselect = factory());\n}(this, (function () { 'use strict';\n\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nreturn quickselect;\n\n})));\n","'use strict';\n\nmodule.exports = rbush;\nmodule.exports.default = rbush;\n\nvar quickselect = require('quickselect');\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","'use strict';\n\nvar toObject = Object;\nvar TypeErr = TypeError;\n\nmodule.exports = function flags() {\n\tif (this != null && this !== toObject(this)) {\n\t\tthrow new TypeErr('RegExp.prototype.flags getter called on non-object');\n\t}\n\tvar result = '';\n\tif (this.global) {\n\t\tresult += 'g';\n\t}\n\tif (this.ignoreCase) {\n\t\tresult += 'i';\n\t}\n\tif (this.multiline) {\n\t\tresult += 'm';\n\t}\n\tif (this.dotAll) {\n\t\tresult += 's';\n\t}\n\tif (this.unicode) {\n\t\tresult += 'u';\n\t}\n\tif (this.sticky) {\n\t\tresult += 'y';\n\t}\n\treturn result;\n};\n","'use strict';\n\nvar define = require('define-properties');\n\nvar implementation = require('./implementation');\nvar getPolyfill = require('./polyfill');\nvar shim = require('./shim');\n\nvar flagsBound = Function.call.bind(implementation);\n\ndefine(flagsBound, {\n\tgetPolyfill: getPolyfill,\n\timplementation: implementation,\n\tshim: shim\n});\n\nmodule.exports = flagsBound;\n","'use strict';\n\nvar implementation = require('./implementation');\n\nvar supportsDescriptors = require('define-properties').supportsDescriptors;\nvar gOPD = Object.getOwnPropertyDescriptor;\nvar TypeErr = TypeError;\n\nmodule.exports = function getPolyfill() {\n\tif (!supportsDescriptors) {\n\t\tthrow new TypeErr('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');\n\t}\n\tif (/a/mig.flags === 'gim') {\n\t\tvar descriptor = gOPD(RegExp.prototype, 'flags');\n\t\tif (descriptor && typeof descriptor.get === 'function' && typeof (/a/).dotAll === 'boolean') {\n\t\t\treturn descriptor.get;\n\t\t}\n\t}\n\treturn implementation;\n};\n","'use strict';\n\nvar supportsDescriptors = require('define-properties').supportsDescriptors;\nvar getPolyfill = require('./polyfill');\nvar gOPD = Object.getOwnPropertyDescriptor;\nvar defineProperty = Object.defineProperty;\nvar TypeErr = TypeError;\nvar getProto = Object.getPrototypeOf;\nvar regex = /a/;\n\nmodule.exports = function shimFlags() {\n\tif (!supportsDescriptors || !getProto) {\n\t\tthrow new TypeErr('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');\n\t}\n\tvar polyfill = getPolyfill();\n\tvar proto = getProto(regex);\n\tvar descriptor = gOPD(proto, 'flags');\n\tif (!descriptor || descriptor.get !== polyfill) {\n\t\tdefineProperty(proto, 'flags', {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tget: polyfill\n\t\t});\n\t}\n\treturn polyfill;\n};\n","module.exports = {\n    bboxPolygon: require('@turf/bbox-polygon').default,\n    helpers: require('@turf/helpers'),\n    meta: require('@turf/meta'),\n    bbox: require('@turf/bbox').default,\n    center: require('@turf/center').default,\n    booleanContains: require('@turf/boolean-contains').default,\n    booleanOverlap: require('@turf/boolean-overlap').default,\n    simplify: require('@turf/simplify').default,\n};\n"]}